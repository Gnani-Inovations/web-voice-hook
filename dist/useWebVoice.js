import AudioMotionAnalyzer from"audiomotion-analyzer";import{useCallback,useMemo,useRef,useState}from"react";import{applyCustomColor,base64ToPCM16Data,convertPCMDataToFloat32,getBase64Audio,getVisualizerOptions,resampleAudio,resetAudioInput}from"./webVoiceUtils";const SAMPLE_RATE=44100;export const CHANNELS=1;export const BITS_PER_SAMPLE=16;const defaultLogger={info:(e,...r)=>console.log("[GnaniWebVoice]",e,...r),error:(e,...r)=>console.error("[GnaniWebVoice]",e,...r)},DEFAULT_WORKLET_PATH="/worklet/audio-processor.js";export const useWebSocketAudio=({websocketUrl:e,workletPath:r=DEFAULT_WORKLET_PATH,visualizerOptions:{elementId:t,color:n,options:c}={},events:o,logger:u})=>{const{onOpen:s,onClose:a,onException:i}=o??{},l=u??defaultLogger,[d,p]=useState(!1),f=useRef(null),g=useRef(null),m=useRef(null),y=useRef(!1),k=useRef(!0),S=useRef(),b=useRef(!1),C=useRef(!1),v=useRef(44100),h=useRef(!1),E=useRef(!1),R=useRef(0),A=useRef(null),[w,O]=useState(!1),P=useRef(!1),N=useRef([]),T=useCallback(()=>(g.current&&"closed"!==g.current.state||(g.current=new(window.AudioContext||window.webkitAudioContext)({sampleRate:44100,latencyHint:"playback"})),g.current),[]),L=useCallback(e=>{if(!t||A.current||C.current)A.current?.connectInput(e);else{const r=new AudioMotionAnalyzer(document.getElementById(t),{...c??getVisualizerOptions(e)});r.start(),n&&applyCustomColor(r,n),A.current=r}},[]),_=useCallback(async()=>{if(!b.current){resetAudioInput(S.current);try{S.current=await navigator.mediaDevices.getUserMedia({audio:{sampleRate:44100,channelCount:1,echoCancellation:{ideal:!0},noiseSuppression:{ideal:!0},autoGainControl:{ideal:!0}}});const e=T(),r=e.createMediaStreamSource(S.current),t=e.createDynamicsCompressor();t.threshold.value=-30,t.knee.value=40,t.ratio.value=8,t.attack.value=.002,t.release.value=.1;const n=e.createGain();n.gain.value=1.2,r.connect(t).connect(n),L(r),b.current=!0}catch(e){throw l.error("Error setting up audio stream:",e),i?.(e),e}}},[T,L]),{startProcessing:I,stopProcessing:M,isProcessing:W}=useMemo(()=>{let e=null,t=null;return{startProcessing:async()=>{if(S.current)try{const n=T();await n.audioWorklet.addModule(r),t=n.createMediaStreamSource(S.current),e=new AudioWorkletNode(n,"audio-processor",{numberOfInputs:1,numberOfOutputs:1,channelCount:1,processorOptions:{sampleRate:n.sampleRate}}),e.port.onmessage=e=>{if(f.current?.readyState===WebSocket.OPEN){const{data:r,timestamp:t}=e.data,n=getBase64Audio(r);f.current.send(JSON.stringify({event:"media",media:{payload:n,timestamp:t}}))}},t.connect(e)}catch(e){l.error("Failed to start audio processing:",e),i?.(e)}},stopProcessing:()=>{e&&(e.disconnect(),e=null),t&&(t.disconnect(),t=null)},isProcessing:!!e}},[T,r]),D=useCallback(e=>{T();try{const r=base64ToPCM16Data(e),t=convertPCMDataToFloat32(r),n=44100===v.current?t:resampleAudio(t,v.current,44100);N.current.push(n),N.current.reduce((e,r)=>e+r.length,0)>=44100&&G()}catch(e){l.error("Error processing audio chunk:",e)}},[T]),G=useCallback(()=>{const e=T();if(!e||P.current)return;let r;if(0===N.current.length){P.current=!1,p(!1),f.current?.send(JSON.stringify({event:"TTS_PLAYING",media:{tts_playing:!1}})),E.current=!1;const e=Math.floor(1*v.current*2);r=new Float32Array(e).fill(0)}else{E.current||(f.current?.send(JSON.stringify({event:"TTS_PLAYING",media:{tts_playing:!0}})),E.current=!0),P.current=!0,p(!0);let e=0;const t=[];for(;N.current.length>0&&e<44100;){const r=N.current.shift();t.push(r),e+=r.length}r=new Float32Array(e);let n=0;for(const e of t)r.set(e,n),n+=e.length}const t=e.createBuffer(1,r.length,44100);t.getChannelData(0).set(r);const n=e.createBufferSource();n.buffer=t,n.connect(e.destination),L(n),n.onended=()=>{P.current=!1,N.current.length>0?G():(p(!1),f.current?.send(JSON.stringify({event:"TTS_PLAYING",media:{tts_playing:!1}})),E.current=!1,h.current&&f.current?.close())},n.start(),m.current=n,y.current=!0},[T,L]),J=useCallback(async e=>{try{"media"===e.event&&e.media?.payload?(0===R.current&&(R.current=Date.now(),l.info("Chunk received at:",R.current)),v.current=e.sample_rate??44100,D(e.media.payload)):["barge","BARGE"].includes(e.event)?(l.info("Barged"),N.current=[]):"EOC"===e.event?(l.info("EOC event occurred"),f.current?.send(JSON.stringify({event:"EOC"}))):"stop"===e.event?(l.info("Stop event occurred"),f.current?.readyState===WebSocket.OPEN&&(h.current=!0)):l.info("Unhandled message type:",e)}catch(e){l.error("Error processing audio message:",e)}},[]),x=useCallback(e=>{if(!C.current){if(C.current=!0,M(),f.current&&(f.current.readyState!==WebSocket.OPEN&&f.current.readyState!==WebSocket.CONNECTING||f.current.close(),f.current=null),A.current?.stop(),A.current?.destroy(),g.current&&(g.current.close(),g.current=null),m.current&&(m.current.stop(),m.current.disconnect(),m.current=null),S.current){S.current.getTracks().forEach(e=>{e.stop(),e.enabled=!1,S.current?.removeTrack(e)}),S.current=void 0}N.current=[],y.current=!1,b.current=!1,k.current=!0,P.current=!1,h.current=!1,p(!1),O(!1),a?.(e)}},[M,a]),B=useCallback(()=>{if(!e||f.current||C.current||w)return;C.current=!1,k.current=!0;const r=new WebSocket(e);f.current=r,r.onopen=async()=>{C.current?r.close():(O(!0),await _(),await I(),r.send(JSON.stringify({event:"start"})))},r.onmessage=e=>{if(!C.current)try{const r=JSON.parse(e.data);r&&J(r)}catch(e){l.error("Error parsing websocket message:",e)}},r.onclose=e=>{"LINK_EXPIRED"===e.reason&&(l.info("Link expired"),location.reload()),C.current||x("server"),M()},r.onerror=e=>{l.error("WebSocket error:",e),i?.(e),C.current||x("server")}},[e,s,a,i,_,I,w]),F=useCallback(()=>{x("client")},[x]),U=useCallback(r=>{if(f.current&&(f.current.close(),f.current=null),C.current=!1,k.current=!0,y.current=!1,b.current=!1,P.current=!1,h.current=!1,O(!1),p(!1),N.current=[],g.current&&(g.current.close(),g.current=null),m.current&&(m.current.stop(),m.current.disconnect(),m.current=null),A.current&&(A.current.stop(),A.current.destroy(),A.current=null),S.current){S.current.getTracks().forEach(e=>{e.stop(),e.enabled=!1,S.current?.removeTrack(e)}),S.current=void 0}if(M(),!e)return void l.error("Cannot reconnect: websocketUrl is required");const t=new WebSocket(e);f.current=t,t.onopen=async()=>{C.current?t.close():(O(!0),await _(),await I(),t.send(JSON.stringify({event:"start"})),r?.())},t.onmessage=e=>{if(!C.current)try{const r=JSON.parse(e.data);r&&J(r)}catch(e){l.error("Error parsing websocket message:",e),i?.(e)}},t.onclose=e=>{"LINK_EXPIRED"===e.reason&&(l.info("Link expired"),location.reload()),C.current||x("server"),M()},t.onerror=e=>{l.error("WebSocket error:",e),i?.(e),C.current||x("server")}},[e,s,a,i,_,I,M,x]);return{isConnected:w,isPlaying:d,startRecording:I,stopRecording:M,isRecording:W,connect:B,disconnect:F,reconnect:U}};
//# sourceMappingURL=useWebVoice.js.map